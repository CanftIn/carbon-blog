# 什么是数值字面量

数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一个数值，无需进行任何计算。例如，`123`、`3.14`、`0xFF`、`1.23e-4` 都可以被视为数值字面量。

字面量的类型通常根据其格式和位置决定。例如，在大多数编程语言中，带有小数点的数字将被视为浮点数（如 3.14），而没有小数点的数字将被视为整数（如 123）。

更复杂的编程语言可能支持其他类型的数值字面量，例如复数、大整数、无穷大、NaN（不是一个数字）等。

Carbon中数值类型有如下几种：

- 整数类型
- 实数类型（总是包含`.`）
- 数字分隔符



如何完成支持数值字面量的解析：

首先需要对数值字面量词法层面提供NumericLiteralToken的抽象，需要存储的数据有：字符数据（text）、小数点字符位置（radix_point）、指数幂字符位置（exponent）。

```c++
class NumericLiteralToken {
 public:
  auto Text() const -> llvm::StringRef { return text; }

  static auto Lex(llvm::StringRef source_text)
      -> llvm::Optional<NumericLiteralToken>;

  class Parser;

 private:
  NumericLiteralToken() {}

  llvm::StringRef text;

  // '.'字符的偏移量
  int radix_point;

  // 'e'或‘p'字符的偏移量
  int exponent;
};
```









```c++
static bool isLower(char c) { return 'a' <= c && c <= 'z'; }

auto NumericLiteralToken::Lex(llvm::StringRef source_text)
    -> llvm::Optional<NumericLiteralToken> {
  NumericLiteralToken result;

  if (source_text.empty() || !llvm::isDigit(source_text.front())) {
    return llvm::None;
  }

  bool seen_plus_minus = false;
  bool seen_radix_point = false;
  bool seen_potential_exponent = false;

  int i = 1, n = source_text.size();
  for (; i != n; ++i) {
    char c = source_text[i];
    if (llvm::isAlnum(c) || c == '_') {
      if (isLower(c) && seen_radix_point && !seen_plus_minus) {
        result.exponent = i;
        seen_potential_exponent = true;
      }
      continue;
    }

    if (c == '.' && i + 1 != n && llvm::isAlnum(source_text[i + 1]) &&
        !seen_radix_point) {
      result.radix_point = i;
      seen_radix_point = true;
      continue;
    }

    if ((c == '+' || c == '-') && seen_potential_exponent &&
        result.exponent == i - 1 && i + 1 != n &&
        llvm::isAlnum(source_text[i + 1])) {
      assert(!seen_plus_minus && "should only consume one + or -");
      seen_plus_minus = true;
      continue;
    }
    break;
  }

  result.text = source_text.substr(0, i);
  if (!seen_radix_point) {
    result.radix_point = i;
  }
  if (!seen_potential_exponent) {
    result.exponent = i;
  }

  return result;
}
```


# 代码

- [numeric_literal step1](/code/numeric_literal/step1)

- [numeric_literal step2](/code/numeric_literal/step2)

# 引用

- [numeric_literals | Carbon](https://github.com/carbon-language/carbon-lang/blob/5d6593ee3949e76cc49b69a81e80ea4b80b5a935/docs/design/lexical_conventions/numeric_literals.md)
- [Floating-point numeric types - C# reference | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)
- [numeric_literals | MDN Web](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#numeric_literals)
- [json-tutorial | miloyip](https://github.com/miloyip/json-tutorial/blob/master/tutorial02/tutorial02.md)
