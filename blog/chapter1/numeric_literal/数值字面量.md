## 什么是数值字面量

数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一个数值，无需进行任何计算。例如，`123`、`3.14`、`0xFF`、`1.23e-4` 都可以被视为数值字面量。

字面量的类型通常根据其格式和位置决定。例如，在大多数编程语言<sup>[[1](#references-anchor)]</sup><sup>[[2](#references-anchor)]</sup><sup>[[3](#references-anchor)]</sup>中，带有小数点的数字将被视为浮点数（如 `3.14`），而没有小数点的数字将被视为整数（如 `123`）。

更复杂的编程语言可能支持其他类型的数值字面量，例如复数、大整数、无穷大、NaN（不是一个数字）等。

本章将从数值字面量的解析入手，开始进入编译器构造的世界。

## Carbon数值类型介绍

Carbon中数值类型<sup>[[4](#references-anchor)]</sup>有如下几种：

- 整数类型

  整数根据进制分为如下类型：十进制（例如 `12345` ）、十六进制（例如 `0x1FE` ）、二进制（例如 `0b1010` ）等

- 实数类型

  实数类型总是包含 `.` 符号，实数类型例如基础类型 `123.456` 以及科学技术法表示 `123.456e789`、`0x1.2p123` 等，其中科学技术法表示中的字符 `e` 及 `p` 在Carbon中称为指数（`exponent` 字符，在幂运算中应为底数），`e` 相当于10<sup>&plusmn;_N_</sup>，而 `p` 相当于2<sup>&plusmn;_N_</sup>。

  且实数类型字面量 `exponent` 字符后可跟随 `+` 或 `-` 字符，例如 `12.34e+56` 或 `56.34e-12`。

- 数字分隔符

  数字分隔符由下划线 `_` 表示，例如十进制数: `1_23_456_7890`、十六进制数: `0x7_F_FF_FFFF`、实数: `2_147.48_3648e12_345` 或 `0x1_00CA.FE_F00Dp+2_4`、二进制数: `0b1_000_101_11` 等。

## 代码实现

如何完成支持数值字面量的解析：

首先需要对数值字面量词法层面提供NumericLiteralToken的抽象，需要存储的数据有：字符数据（text）、小数点字符位置（radix_point）、指数幂字符位置（exponent）。

```c++
class NumericLiteralToken {
 public:
  auto Text() const -> llvm::StringRef { return text; }

  static auto Lex(llvm::StringRef source_text)
      -> llvm::Optional<NumericLiteralToken>;

  class Parser;

 private:
  NumericLiteralToken() {}

  llvm::StringRef text;

  // '.'字符的偏移量
  int radix_point;

  // 'e'或'p'字符的偏移量
  int exponent;
};
```









```c++
static bool isLower(char c) { return 'a' <= c && c <= 'z'; }

auto NumericLiteralToken::Lex(llvm::StringRef source_text)
    -> llvm::Optional<NumericLiteralToken> {
  NumericLiteralToken result;

  if (source_text.empty() || !llvm::isDigit(source_text.front())) {
    return llvm::None;
  }

  bool seen_plus_minus = false;
  bool seen_radix_point = false;
  bool seen_potential_exponent = false;

  int i = 1, n = source_text.size();
  for (; i != n; ++i) {
    char c = source_text[i];
    if (llvm::isAlnum(c) || c == '_') {
      if (isLower(c) && seen_radix_point && !seen_plus_minus) {
        result.exponent = i;
        seen_potential_exponent = true;
      }
      continue;
    }

    if (c == '.' && i + 1 != n && llvm::isAlnum(source_text[i + 1]) &&
        !seen_radix_point) {
      result.radix_point = i;
      seen_radix_point = true;
      continue;
    }

    if ((c == '+' || c == '-') && seen_potential_exponent &&
        result.exponent == i - 1 && i + 1 != n &&
        llvm::isAlnum(source_text[i + 1])) {
      assert(!seen_plus_minus && "should only consume one + or -");
      seen_plus_minus = true;
      continue;
    }
    break;
  }

  result.text = source_text.substr(0, i);
  if (!seen_radix_point) {
    result.radix_point = i;
  }
  if (!seen_potential_exponent) {
    result.exponent = i;
  }

  return result;
}
```

# 什么是APInt

参考阅读[什么是APInt](/blog/chapter12/llvm/section1.1_LLVM_ADT_APInt介绍.md)链接。

# 代码

- [numeric_literal section1](/code/numeric_literal/section1)

- [numeric_literal step2](/code/numeric_literal/step2)

<div id="references-anchor"></div>

# 引用

- [1] : [Floating-point numeric types - C# reference | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)
- [2] : [numeric_literals | MDN Web](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#numeric_literals)
- [3] : [json-tutorial | miloyip](https://github.com/miloyip/json-tutorial/blob/master/tutorial02/tutorial02.md)
- [4] : [numeric_literals | Carbon](https://github.com/carbon-language/carbon-lang/blob/5d6593ee3949e76cc49b69a81e80ea4b80b5a935/docs/design/lexical_conventions/numeric_literals.md)
