## 什么是数值字面量

数值字面量（Numeric Literals）在编程中是表示特定数值的一个符号或一组符号。这些字面量用于直接在源代码中表示一个数值，无需进行任何计算。例如 `123`、`3.14`、`0xFF`、`1.23e-4` 都可以被视为数值字面量。

字面量的类型通常根据其格式和位置决定。例如在大多数编程语言<sup>[[1](#references-anchor)]</sup><sup>[[2](#references-anchor)]</sup><sup>[[3](#references-anchor)]</sup>中，带有小数点的数字将被视为浮点数（如 `3.14` ），而没有小数点的数字将被视为整数（如 `123` ）。

更复杂的编程语言可能支持其他类型的数值字面量，例如复数、大整数、无穷大、NaN（不是一个数字）等。

本章将从数值字面量的解析入手，开始进入编译器构造的世界。

## Carbon数值类型介绍

Carbon中数值类型<sup>[[4](#references-anchor)]</sup>有如下几种：

- 整数类型

  整数根据进制分为如下类型：十进制（例如 `12345` ）、十六进制（例如 `0x1FE` ）、二进制（例如 `0b1010` ）等

- 实数类型

  实数类型总是包含 `.` 符号，实数类型例如基础类型 `123.456` 以及科学技术法表示 `123.456e789`、`0x1.2p123` 等，其中科学技术法表示中的字符 `e` 及 `p` 在Carbon中称为指数（对应代码中`exponent` 字符，实际在幂运算中应为底数），对于一个十进制值 _N_ 来说，`e` 相当于10<sup>&plusmn;_N_</sup>，而 `p` 相当于2<sup>&plusmn;_N_</sup>。

  且实数类型字面量 `exponent` 字符后可跟随 `+` 或 `-` 字符，例如 `12.34e+56` 或 `56.34e-12`。

- 数字分隔符

  数字分隔符由下划线 `_` 表示，例如十进制数: `1_23_456_7890`、十六进制数: `0x7_F_FF_FFFF`、实数: `2_147.48_3648e12_345` 或 `0x1_00CA.FE_F00Dp+2_4`、二进制数: `0b1_000_101_11` 等。

## 代码实现

如何完成支持数值字面量的解析：

首先需要在字符串层面对数值字面量进行字符串切分，由于字符中数字分隔符即 `_` 下划线只用于提升长数值的阅读性，对其不做处理，而其他字符如小数点及 `exponent` 字符需要获取其在字符串中所在位置，便于下一步的处理。于是在词法层面提供`NumericLiteralToken`类的抽象，需要存储的数据有：字符数据（`text`）、小数点字符位置（`radix_point`）、指数幂字符位置（`exponent`）。

```c++
class NumericLiteralToken {
 public:
  auto Text() const -> llvm::StringRef { return text; }

  static auto Lex(llvm::StringRef source_text)
      -> llvm::Optional<NumericLiteralToken>;

  auto GetRadixPoint() -> int { return radix_point; }

  auto GetExponent() -> int { return exponent; }

 private:
  NumericLiteralToken() {}

  llvm::StringRef text;

  // '.'字符的偏移量
  int radix_point;

  // 'e'或'p'字符的偏移量
  int exponent;
};
```

上述代码参考[numeric_literal section1](/code/numeric_literal/section1)，其中我们重点关注Lex接口的实现：

```c++
auto NumericLiteralToken::Lex(llvm::StringRef source_text)
    -> llvm::Optional<NumericLiteralToken> {
  NumericLiteralToken result;

  // 判断source_text是否为空以及第一个字符是否为数字
  if (source_text.empty() || !IsDecimalDigit(source_text.front())) {
    return llvm::None;
  }

  bool seen_plus_minus = false;
  bool seen_radix_point = false;
  bool seen_potential_exponent = false;

  // 由于之前已经确认过首字符，这里索引从1开始
  int i = 1;
  for (int n = source_text.size(); i != n; ++i) {
    char c = source_text[i];
    if (IsAlnum(c) || c == '_') {
      // 只支持小写的 'e'，如果存在该字符且发现点号以及未探索
      // 到加减号则记录exponent索引位置，否则继续下一轮循环
      if (IsLower(c) && seen_radix_point && !seen_plus_minus) {
        result.exponent = i;
        seen_potential_exponent = true;
      }
      continue;
    }

    // 当前字符为 '.' 时，记录radix_point
    if (c == '.' && i + 1 != n && IsAlnum(source_text[i + 1]) &&
        !seen_radix_point) {
      result.radix_point = i;
      seen_radix_point = true;
      continue;
    }

    // 当前字符为 '+' 或 '-' 时，记录seen_plus_minus
    if ((c == '+' || c == '-') && seen_potential_exponent &&
        result.exponent == i - 1 && i + 1 != n &&
        IsAlnum(source_text[i + 1])) {
      assert(!seen_plus_minus && "should only consume one + or -");
      seen_plus_minus = true;
      continue;
    }
    break;
  }

  // 返回探索到的字符串，以当前i的值为索引切分子串
  result.text = source_text.substr(0, i);
  // 记录 '.' 偏移
  if (!seen_radix_point) {
    result.radix_point = i;
  }
  // 记录 'e' 或 'p' 偏移
  if (!seen_potential_exponent) {
    result.exponent = i;
  }

  return result;
}
```

以上代码中，`source_text`用于接受外部传入的数值字符串，该类型为`llvm::StringRef`类型（StringRef类型分析可参考[chapter12_s1.2: LLVM ADT StringRef介绍及使用](/blog/chapter12/llvm/section1.2_LLVM_ADT_StringRef介绍及使用.md)），首先判断`source_text`是否为空以及第一个字符是否为数字，如果不满足条件则返回`llvm::None`，`llvm::None`实际为一个枚举数值类型，返回值为`llvm::Optional`（Optional类型分析可参考[chapter12_s1.3: LLVM ADT Optional介绍及使用](/blog/chapter12/llvm/section1.3_LLVM_ADT_Optional介绍及使用.md)）。

接下来使用三个变量`seen_plus_minus`（是否探索到 `+` 或 `-` ）、`seen_radix_point`（是否探索到 `.` ）、`seen_potential_exponent`（是否探索到 `e` 或者 `p` ）用于后续词法解析的条件判断。

在下一步字符串循环中，不断去除当前字符并做判断，直到不满足所以条件判断要求跳出循环。

跳出循环后记录对应数据存入返回值NumericLiteralToken对象的变量中。

## 什么是APInt

参考阅读[什么是APInt](/blog/chapter12/llvm/section1.1_LLVM_ADT_APInt介绍.md)链接。


<div id="references-anchor"></div>

## 引用

- [1] : [Floating-point numeric types - C# reference | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types)
- [2] : [numeric_literals | MDN Web](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#numeric_literals)
- [3] : [json-tutorial | miloyip](https://github.com/miloyip/json-tutorial/blob/master/tutorial02/tutorial02.md)
- [4] : [numeric_literals | Carbon](https://github.com/carbon-language/carbon-lang/blob/5d6593ee3949e76cc49b69a81e80ea4b80b5a935/docs/design/lexical_conventions/numeric_literals.md)
